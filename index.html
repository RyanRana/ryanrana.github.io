<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Ryan Rana</title>
    <link rel="icon" type="image/jpeg" href="D343F409-4896-409D-99CD-BC68701F352C copy.JPEG">
    <meta name="description" content="Ryan Rana's personal website - Focused on Applied AI and Software Architecture">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://unpkg.com/d3-delaunay@6"></script>
</head>
<body>
    <!-- Header -->
    <header class="site-header">
        <div class="header-content">
            <h1 class="site-title">
                <a href="index.html">ryanrana._</a>
            </h1>
            <nav class="site-nav">
                <ul>
                    <li><a class="page-link" href="articles.html">01 // articles</a></li>
                    <li><a class="page-link" href="expierence.html">02 // experience</a></li>
                    <li><a class="page-link" href="projects.html">03 // projects</a></li>
                    <li><a class="page-link" href="resume.pdf">04 // resume</a></li>
                    <li><a class="page-link" href="contact.html">05 // contact</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <main class="content">
        <div class="container">
            <div class="homepage-layout">
                <!-- Left Side - Content Only -->
                <div class="homepage-content">
                    <h1 class="main-name">Ryan Rana</h1>
                    <p class="description">
                        Interested in agentic AI & scalable software architecture.
                    </p>
                    <br>
                    <p class="description">
                        Currently studying CS @ <a href="https://newbrunswick.rutgers.edu/">Rutgers</a> & coding @ 
                        <a href="https://www.undergraduation.com/">Undergraduation</a>
                    </p>
                    <br>
                    <p class="description">
                        Happiest skiing, golfing, eating Chipotle, and building <a href="https://github.com/RyanRana">software</a> that helps people.
                    </p>
                    <br>
                    <p class="description">
                        There’s nothing better than turning a good conversation into a working prototype. Always down to chat.
                    </p>
                </div>
                
                <!-- Right Side - Blob Visual Effect -->
                <div class="blob-container">
                    <canvas id="c"></canvas>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="site-footer">
        <div class="container">
            <p>&copy; 2025 Ryan Rana</p>
        </div>
    </footer>
    <script>
        (() => {
          const canvas = document.getElementById('c');
          if (!canvas) return;
      
          const ctx = canvas.getContext('2d');
          const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      
          // Page-specific parameters
          const CELL_MIN = 12; // fewer cells → larger blobs
          const CELL_MAX = 18;
          const PALETTE = [217, 262, 188, 346, 45, 160]; // default pastel-ish hues
      
          const PADDING = 12 * DPR;
          const cornerSmoothIterations = 5;
      
          const rand = (a, b) => a + Math.random() * (b - a);
          const HSL = (h, s, l) => `hsl(${h}, ${s}%, ${l}%)`;
      
          function centroid(poly) {
            let x = 0, y = 0, a = 0;
            for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
              const p1 = poly[j], p2 = poly[i];
              const f = (p1[0] * p2[1] - p2[0] * p1[1]);
              x += (p1[0] + p2[0]) * f;
              y += (p1[1] + p2[1]) * f;
              a += f;
            }
            a *= 0.5;
            if (a === 0) {
              let sx = 0, sy = 0; for (const p of poly) { sx += p[0]; sy += p[1]; }
              return [sx / poly.length, sy / poly.length];
            }
            return [x / (6 * a), y / (6 * a)];
          }
      
          function chaikin(points, iterations = 1) {
            let pts = points.slice();
            for (let k = 0; k < iterations; k++) {
              const out = [];
              for (let i = 0; i < pts.length; i++) {
                const p0 = pts[i];
                const p1 = pts[(i + 1) % pts.length];
                const Q = [0.75 * p0[0] + 0.25 * p1[0], 0.75 * p0[1] + 0.25 * p1[1]];
                const R = [0.25 * p0[0] + 0.75 * p1[0], 0.25 * p0[1] + 0.75 * p1[1]];
                out.push(Q, R);
              }
              pts = out;
            }
            return pts;
          }
      
          function drawRoundedPath(ctx, pts) {
            const n = pts.length; if (!n) return;
            ctx.beginPath();
            for (let i = 0; i < n; i++) {
              const p1 = pts[i];
              const p2 = pts[(i + 1) % n];
              const mx = (p1[0] + p2[0]) / 2 / DPR;
              const my = (p1[1] + p2[1]) / 2 / DPR;
              if (i === 0) ctx.moveTo(mx, my);
              ctx.quadraticCurveTo(p1[0] / DPR, p1[1] / DPR, mx, my);
            }
            ctx.closePath();
          }
      
          function randomSites(w, h, n) {
            const sites = [];
            for (let i = 0; i < n; i++) {
              sites.push([rand(PADDING, w - PADDING), rand(PADDING, h - PADDING)]);
            }
            return sites;
          }
      
          function lloydRelax(sites, bbox, iterations = 2) {
            for (let k = 0; k < iterations; k++) {
              const vor = d3.Delaunay.from(sites).voronoi(bbox);
              const refined = [];
              for (let i = 0; i < sites.length; i++) {
                const cell = vor.cellPolygon(i);
                if (!cell) { refined.push(sites[i]); continue; }
                let cx = 0, cy = 0; for (const p of cell) { cx += p[0]; cy += p[1]; }
                refined.push([cx / cell.length, cy / cell.length]);
              }
              sites = refined;
            }
            return sites;
          }
      
          let state = { polys: [], colors: [] };
          let mousePos = { x: -1e9, y: -1e9 };
          let explosions = [];
      
          function regenerate() {
            const w = canvas.width, h = canvas.height;
            const count = Math.floor(rand(CELL_MIN, CELL_MAX + 1));
            let sites = randomSites(w, h, count);
            sites = lloydRelax(sites, [PADDING, PADDING, w - PADDING, h - PADDING], 2);
      
            const delaunay = d3.Delaunay.from(sites);
            const vor = delaunay.voronoi([PADDING, PADDING, w - PADDING, h - PADDING]);
      
            const polys = [];
            for (let i = 0; i < sites.length; i++) {
              const cell = vor.cellPolygon(i);
              if (!cell) continue;
              let poly = cell.map(([x, y]) => [x, y]);
              poly = chaikin(poly, cornerSmoothIterations);
              const c = centroid(poly);
              const inset = 18 * DPR;
              poly = poly.map(([x, y]) => {
                const vx = x - c[0], vy = y - c[1];
                const mag = Math.hypot(vx, vy) || 1;
                return [x - (vx / mag) * inset, y - (vy / mag) * inset];
              });
      
              const hue = PALETTE[i % PALETTE.length];
              polys.push({
                poly,
                center: c.slice(),
                originalCenter: c.slice(),
                originalPoly: poly.map(p => p.slice()),
                hue,
                baseHue: hue,
                targetHue: hue,
                velocity: { x: 0, y: 0 },
                breathPhase: Math.random() * Math.PI * 2,
                colorPhase: Math.random() * Math.PI * 2,
                colorSpeed: rand(0.005, 0.015),
                lastRenderedHue: null
              });
            }
      
            state = { polys, colors: polys.map(({ hue }) => HSL(hue, 70, 75)) };
          }
      
          function updateNaturalColors() {
            for (let blob of state.polys) {
              blob.colorPhase += blob.colorSpeed;
              const hueOffset = Math.sin(blob.colorPhase) * 30;
              blob.hue = (blob.baseHue + hueOffset + 360) % 360;
            }
          }
      
          function updateBreathing() {
            for (let blob of state.polys) {
              blob.breathPhase += 0.012;
              const s = 1 + Math.sin(blob.breathPhase) * 0.08;
              for (let i = 0; i < blob.poly.length; i++) {
                const dx = blob.originalPoly[i][0] - blob.originalCenter[0];
                const dy = blob.originalPoly[i][1] - blob.originalCenter[1];
                blob.poly[i][0] = blob.center[0] + dx * s;
                blob.poly[i][1] = blob.center[1] + dy * s;
              }
            }
          }
      
          function updateBlobPositions() {
            const w = canvas.width, h = canvas.height;
      
            explosions = explosions.filter(ex => { ex.strength *= 0.95; ex.age += 1; return ex.age < 120; });
      
            for (let blob of state.polys) {
              const dx = mousePos.x - blob.center[0];
              const dy = mousePos.y - blob.center[1];
              const dist = Math.hypot(dx, dy);
      
              const AVOIDANCE_RADIUS = 120 * DPR;
              const ATTRACTION_RANGE = 300 * DPR;
      
              for (let ex of explosions) {
                const exdx = blob.center[0] - ex.x;
                const exdy = blob.center[1] - ex.y;
                const exd = Math.hypot(exdx, exdy);
                if (exd < ex.radius && exd > 0) {
                  const f = ex.strength * (ex.radius - exd) / ex.radius;
                  blob.velocity.x += (exdx / exd) * f;
                  blob.velocity.y += (exdy / exd) * f;
                }
              }
      
              if (dist < AVOIDANCE_RADIUS && dist > 0) {
                const f = (AVOIDANCE_RADIUS - dist) / AVOIDANCE_RADIUS * 6.0;
                blob.velocity.x -= (dx / dist) * f;
                blob.velocity.y -= (dy / dist) * f;
              } else if (dist < ATTRACTION_RANGE && dist >= AVOIDANCE_RADIUS) {
                const f = (ATTRACTION_RANGE - dist) / ATTRACTION_RANGE * 1.5;
                blob.velocity.x += (dx / dist) * f;
                blob.velocity.y += (dy / dist) * f;
              }
      
              const returnForce = 0.03;
              const bdx = blob.originalCenter[0] - blob.center[0];
              const bdy = blob.originalCenter[1] - blob.center[1];
              blob.velocity.x += bdx * returnForce;
              blob.velocity.y += bdy * returnForce;
      
              // keep inside bounds
              blob.center[0] = Math.max(PADDING, Math.min(w - PADDING, blob.center[0] + (blob.velocity.x *= 0.80)));
              blob.center[1] = Math.max(PADDING, Math.min(h - PADDING, blob.center[1] + (blob.velocity.y *= 0.80)));
            }
          }
      
          function updateColorSpreading() {
            for (let i = 0; i < state.polys.length; i++) {
              const a = state.polys[i];
              let sum = 0, weight = 0;
              for (let j = 0; j < state.polys.length; j++) {
                if (i === j) continue;
                const b = state.polys[j];
                const d = Math.hypot(b.center[0] - a.center[0], b.center[1] - a.center[1]);
                if (d < 80 * DPR) {
                  const wgt = (80 * DPR - d) / (80 * DPR) * 0.02;
                  sum += b.hue * wgt; weight += wgt;
                }
              }
              if (weight > 0) {
                const avg = sum / weight;
                a.targetHue = a.hue + (avg - a.hue) * 0.05;
                a.hue += (a.targetHue - a.hue) * 0.01;
              }
            }
            for (let i = 0; i < state.polys.length; i++) {
              const blob = state.polys[i];
              if (Math.abs(blob.hue - blob.lastRenderedHue) > 1 || !blob.lastRenderedHue) {
                state.colors[i] = HSL(blob.hue, 70, 75);
                blob.lastRenderedHue = blob.hue;
              }
            }
          }
      
          function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < state.polys.length; i++) {
              ctx.fillStyle = state.colors[i];
              drawRoundedPath(ctx, state.polys[i].poly);
              ctx.fill();
            }
          }
      
          function animate() {
            updateNaturalColors();
            updateBlobPositions();
            updateBreathing();
            updateColorSpreading();
            draw();
            requestAnimationFrame(animate);
          }
      
          function onMove(e) {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = (e.clientX - rect.left) * (canvas.width / rect.width);
            mousePos.y = (e.clientY - rect.top) * (canvas.height / rect.height);
          }
      
          function onClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            explosions.push({ x, y, radius: 300 * DPR, strength: 25, age: 0 });
          }
      
          function resize() {
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const w = Math.floor(rect.width);
            const h = Math.floor(rect.height);
            canvas.width = w * DPR;
            canvas.height = h * DPR;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            regenerate();
            draw();
          }
      
          window.addEventListener('resize', resize);
          canvas.addEventListener('mousemove', onMove);
          canvas.addEventListener('click', onClick);
      
          resize();
          requestAnimationFrame(animate);
        })();
        </script>
    <!-- Enhanced JavaScript -->
<!--
    <script>

        // Simple Blob Visual Effect with Natural Color Changes and Breathing
        (() => {
            const canvas = document.getElementById('blobCanvas');
            if (!canvas) return;
            
            const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
            const CELL_MIN = 18; // blob1 defaults
            const CELL_MAX = 24;
            const PADDING = 12 * DPR; // blob1 uses DPR-scaled padding
            const cornerSmoothIterations = 5; // blob1 smoothing

            const rand = (a,b) => a + Math.random()*(b-a);
            const HSL = (h,s,l) => `hsl(${h}, ${s}%, ${l}%)`;
            const PALETTE = [217, 262, 188, 346, 45, 160];

            function centroid(poly) {
                let x=0,y=0,a=0;
                for (let i=0, j=poly.length-1; i<poly.length; j=i++) {
                    const p1 = poly[j], p2 = poly[i];
                    const f = (p1[0]*p2[1] - p2[0]*p1[1]);
                    x += (p1[0] + p2[0]) * f;
                    y += (p1[1] + p2[1]) * f;
                    a += f;
                }
                a *= 0.5;
                if (a === 0) {
                    let sx=0, sy=0; for (const p of poly) { sx+=p[0]; sy+=p[1]; }
                    return [sx/poly.length, sy/poly.length];
                }
                return [x/(6*a), y/(6*a)];
            }

            function chaikin(points, iterations=1) {
                let pts = points.slice();
                for (let k=0; k<iterations; k++) {
                    const out = [];
                    for (let i=0; i<pts.length; i++) {
                        const p0 = pts[i];
                        const p1 = pts[(i+1)%pts.length];
                        const Q = [0.75*p0[0] + 0.25*p1[0], 0.75*p0[1] + 0.25*p1[1]];
                        const R = [0.25*p0[0] + 0.75*p1[0], 0.25*p0[1] + 0.75*p1[1]];
                        out.push(Q, R);
                    }
                    pts = out;
                }
                return pts;
            }

            function drawRoundedPath(ctx, pts) {
                const n = pts.length;
                if (!n) return;
                ctx.beginPath();
                for (let i = 0; i < n; i++) {
                    const p1 = pts[i];
                    const p2 = pts[(i + 1) % n];
                    const mx = (p1[0] + p2[0]) / 2 / DPR;
                    const my = (p1[1] + p2[1]) / 2 / DPR;
                    if (i === 0) ctx.moveTo(mx, my);
                    ctx.quadraticCurveTo(p1[0] / DPR, p1[1] / DPR, mx, my);
                }
                ctx.closePath();
            }

            function randomSites(w, h, n) {
                const sites = [];
                for (let i = 0; i < n; i++) {
                    sites.push([rand(PADDING, w - PADDING), rand(PADDING, h - PADDING)]);
                }
                return sites;
            }

            let state = { polys: [], colors: [] };
            let mousePos = { x: -1e9, y: -1e9 };
            let animationsRunning = false;
            let explosions = [];
            
            function resize() {
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                const w = Math.floor(rect.width);
                const h = Math.floor(rect.height);
                canvas.width = w * DPR;
                canvas.height = h * DPR;
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
                    regenerate();
                draw();
            }

            function lloydRelax(sites, bbox, iterations = 2) {
                for (let k = 0; k < iterations; k++) {
                    const vor = d3.Delaunay.from(sites).voronoi(bbox);
                    const refined = [];
                    for (let i = 0; i < sites.length; i++) {
                        const cell = vor.cellPolygon(i);
                        if (!cell) { refined.push(sites[i]); continue; }
                        let cx = 0, cy = 0; for (const p of cell) { cx += p[0]; cy += p[1]; }
                        refined.push([cx / cell.length, cy / cell.length]);
                    }
                    sites = refined;
                }
                return sites;
            }

            function regenerate() {
                const w = canvas.width, h = canvas.height;
                const count = Math.floor(rand(CELL_MIN, CELL_MAX + 1));
                let sites = randomSites(w, h, count);
                sites = lloydRelax(sites, [PADDING, PADDING, w - PADDING, h - PADDING], 2);
                const delaunay = d3.Delaunay.from(sites);
                const vor = delaunay.voronoi([PADDING, PADDING, w - PADDING, h - PADDING]);
                
                const polys = [];
                for (let i=0; i<sites.length; i++) {
                    const cell = vor.cellPolygon(i);
                    if (!cell) continue;
                    let poly = cell.map(([x,y]) => [x, y]);
                    poly = chaikin(poly, cornerSmoothIterations);
                    const c = centroid(poly);
                    const inset = 18 * DPR; // blob1 inset
                    poly = poly.map(([x,y]) => {
                        const vx = x - c[0], vy = y - c[1];
                        const mag = Math.hypot(vx, vy) || 1;
                        return [x - (vx/mag)*inset, y - (vy/mag)*inset];
                    });

                    const hue = PALETTE[i % PALETTE.length];
                    polys.push({ 
                        poly, 
                        center: c, 
                        originalCenter: [...c],
                        originalPoly: poly.map(point => [...point]),
                        hue,
                        baseHue: hue,
                        targetHue: hue,
                        velocity: { x: 0, y: 0 },
                        lastRenderedHue: null,
                        breathPhase: Math.random() * Math.PI * 2,
                        colorPhase: Math.random() * Math.PI * 2,
                        colorSpeed: rand(0.005, 0.015)
                    });
                }

                state = {
                    polys,
                    colors: polys.map(({hue}) => HSL(hue, 70, 75))
                };
            }

            function updateNaturalColors() {
                for (let blob of state.polys) {
                    blob.colorPhase += blob.colorSpeed;
                    const hueOffset = Math.sin(blob.colorPhase) * 30;
                    blob.hue = (blob.baseHue + hueOffset + 360) % 360;
                }
            }

            function updateBreathing() {
                for (let blob of state.polys) {
                    blob.breathPhase += 0.012; // Much slower breathing (0.025 → 0.012)
                    const breathScale = 1 + Math.sin(blob.breathPhase) * 0.08; // Keep exaggerated amplitude
                    
                    for (let i = 0; i < blob.poly.length; i++) {
                        const dx = blob.originalPoly[i][0] - blob.originalCenter[0];
                        const dy = blob.originalPoly[i][1] - blob.originalCenter[1];
                        blob.poly[i][0] = blob.center[0] + dx * breathScale;
                        blob.poly[i][1] = blob.center[1] + dy * breathScale;
                    }
                }
            }

            function updateBlobPositions() {
                const w = canvas.width, h = canvas.height;
                explosions = explosions.filter(ex => { ex.strength *= 0.95; ex.age += 1; return ex.age < 120; });
                for (let blob of state.polys) {
                    const dx = mousePos.x - blob.center[0];
                    const dy = mousePos.y - blob.center[1];
                    const distance = Math.hypot(dx, dy);
                    const AVOIDANCE_RADIUS = 120 * DPR;
                    const ATTRACTION_RANGE = 300 * DPR;
                    for (let ex of explosions) {
                        const exdx = blob.center[0] - ex.x;
                        const exdy = blob.center[1] - ex.y;
                        const exd = Math.hypot(exdx, exdy);
                        if (exd < ex.radius && exd > 0) {
                            const f = ex.strength * (ex.radius - exd) / ex.radius;
                            blob.velocity.x += (exdx / exd) * f;
                            blob.velocity.y += (exdy / exd) * f;
                        }
                    }
                    if (distance < AVOIDANCE_RADIUS && distance > 0) {
                        const f = (AVOIDANCE_RADIUS - distance) / AVOIDANCE_RADIUS * 6.0;
                        blob.velocity.x -= (dx / distance) * f;
                        blob.velocity.y -= (dy / distance) * f;
                    } else if (distance < ATTRACTION_RANGE && distance >= AVOIDANCE_RADIUS) {
                        const f = (ATTRACTION_RANGE - distance) / ATTRACTION_RANGE * 1.5;
                        blob.velocity.x += (dx / distance) * f;
                        blob.velocity.y += (dy / distance) * f;
                    }
                    const returnForce = 0.03;
                    const bdx = blob.originalCenter[0] - blob.center[0];
                    const bdy = blob.originalCenter[1] - blob.center[1];
                    blob.velocity.x += bdx * returnForce;
                    blob.velocity.y += bdy * returnForce;
                    blob.center[0] = Math.max(PADDING, Math.min(w - PADDING, blob.center[0] + (blob.velocity.x *= 0.80)));
                    blob.center[1] = Math.max(PADDING, Math.min(h - PADDING, blob.center[1] + (blob.velocity.y *= 0.80)));
                }
            }

            function updateColorSpreading() {
                for (let i = 0; i < state.polys.length; i++) {
                    const blob1 = state.polys[i];
                    let hueInfluence = 0;
                    let influenceCount = 0;
                    
                    for (let j = 0; j < state.polys.length; j++) {
                        if (i === j) continue;
                        const blob2 = state.polys[j];
                        const distance = Math.hypot(
                            blob2.center[0] - blob1.center[0],
                            blob2.center[1] - blob1.center[1]
                        );
                        
                        if (distance < 80 * DPR) {
                            const influence = (80 * DPR - distance) / (80 * DPR) * 0.02;
                            hueInfluence += blob2.hue * influence;
                            influenceCount += influence;
                        }
                    }
                    
                    if (influenceCount > 0) {
                        const avgInfluence = hueInfluence / influenceCount;
                        blob1.targetHue = blob1.hue + (avgInfluence - blob1.hue) * 0.05;
                        blob1.hue += (blob1.targetHue - blob1.hue) * 0.01;
                    }
                }
                
                for (let i = 0; i < state.polys.length; i++) {
                    const blob = state.polys[i];
                    if (Math.abs(blob.hue - blob.lastRenderedHue) > 1 || !blob.lastRenderedHue) {
                        state.colors[i] = HSL(blob.hue, 70, 75);
                        blob.lastRenderedHue = blob.hue;
                    }
                }
            }


            function draw() {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < state.polys.length; i++) {
                    ctx.fillStyle = state.colors[i];
                    drawRoundedPath(ctx, state.polys[i].poly);
                        ctx.fill();
                }
            }

            function animate() {
                updateNaturalColors();
                updateBlobPositions();
                updateBreathing();
                updateColorSpreading();
                draw();
                animationId = requestAnimationFrame(animate);
            }


            function onMove(e) {
                const rect = canvas.getBoundingClientRect();
                // Use exact same calculation as click to eliminate offset
                mousePos.x = (e.clientX - rect.left) * (canvas.width / rect.width);
                mousePos.y = (e.clientY - rect.top) * (canvas.height / rect.height);
            }

            function onClick(e) {
                const rect = canvas.getBoundingClientRect();
                // Use same coordinate system for both mouse and explosion
                const clickX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const clickY = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                // Create explosion at click point
                explosions.push({
                    x: clickX,
                    y: clickY,
                    radius: 300 * DPR, // Larger blast radius (200 → 300)
                    strength: 25, // Much stronger explosion (8 → 25)
                    age: 0
                });

                
            }

            window.addEventListener('resize', resize);
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('click', onClick);

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    resize();
                    animate();
                });
            } else {
                resize();
                animate();
            }
        })();
    </script>
    -->
</body>
</html>