<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Voronoi Blobs 3</title>
  <style>
    html, body { height: 100%; margin: 0; background: #ffffff; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
  <script src="https://unpkg.com/d3-delaunay@6"></script>
</head>
<body>
  <canvas id="c"></canvas>
  <script>
  (()=>{
    const canvas=document.getElementById('c'); if(!canvas) return; const ctx=canvas.getContext('2d');
    const DPR=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const CELL_MIN=24, CELL_MAX=30; const PALETTE=[200,210,220,190,230,240]; // cool hues
    const PADDING=12*DPR; const cornerSmoothIterations=5;
    const rand=(a,b)=>a+Math.random()*(b-a); const HSL=(h,s,l)=>`hsl(${h}, ${s}%, ${l}%)`;

    function centroid(poly){ let x=0,y=0,a=0; for(let i=0,j=poly.length-1;i<poly.length;j=i++){
      const p1=poly[j], p2=poly[i]; const f=(p1[0]*p2[1]-p2[0]*p1[1]); x+=(p1[0]+p2[0])*f; y+=(p1[1]+p2[1])*f; a+=f; }
      a*=0.5; if(a===0){ let sx=0,sy=0; for(const p of poly){ sx+=p[0]; sy+=p[1]; } return [sx/poly.length, sy/poly.length]; } return [x/(6*a), y/(6*a)]; }
    function chaikin(points,iterations=1){ let pts=points.slice(); for(let k=0;k<iterations;k++){ const out=[]; for(let i=0;i<pts.length;i++){ const p0=pts[i], p1=pts[(i+1)%pts.length]; const Q=[0.75*p0[0]+0.25*p1[0], 0.75*p0[1]+0.25*p1[1]]; const R=[0.25*p0[0]+0.75*p1[0], 0.25*p0[1]+0.75*p1[1]]; out.push(Q,R);} pts=out;} return pts; }
    function drawRoundedPath(ctx,pts){ const n=pts.length; if(!n) return; ctx.beginPath(); for(let i=0;i<n;i++){ const p1=pts[i], p2=pts[(i+1)%n]; const mx=(p1[0]+p2[0])/2/DPR, my=(p1[1]+p2[1])/2/DPR; if(i===0) ctx.moveTo(mx,my); ctx.quadraticCurveTo(p1[0]/DPR, p1[1]/DPR, mx, my);} ctx.closePath(); }
    function randomSites(w,h,n){ const s=[]; for(let i=0;i<n;i++) s.push([rand(PADDING,w-PADDING), rand(PADDING,h-PADDING)]); return s; }
    function lloydRelax(sites,bbox,iterations=2){ for(let k=0;k<iterations;k++){ const vor=d3.Delaunay.from(sites).voronoi(bbox); const refined=[]; for(let i=0;i<sites.length;i++){ const cell=vor.cellPolygon(i); if(!cell){ refined.push(sites[i]); continue; } let cx=0,cy=0; for(const p of cell){ cx+=p[0]; cy+=p[1]; } refined.push([cx/cell.length, cy/cell.length]); } sites=refined; } return sites; }

    let state={polys:[], colors:[]}; let mousePos={x:-1e9,y:-1e9}; let explosions=[];
    function regenerate(){ const w=canvas.width,h=canvas.height; const count=Math.floor(rand(CELL_MIN,CELL_MAX+1)); let sites=randomSites(w,h,count); sites=lloydRelax(sites,[PADDING,PADDING,w-PADDING,h-PADDING],2); const vor=d3.Delaunay.from(sites).voronoi([PADDING,PADDING,w-PADDING,h-PADDING]); const polys=[]; for(let i=0;i<sites.length;i++){ const cell=vor.cellPolygon(i); if(!cell) continue; let poly=cell.map(([x,y])=>[x,y]); poly=chaikin(poly,cornerSmoothIterations); const c=centroid(poly); const inset=18*DPR; poly=poly.map(([x,y])=>{ const vx=x-c[0], vy=y-c[1]; const m=Math.hypot(vx,vy)||1; return [x-(vx/m)*inset, y-(vy/m)*inset]; }); const hue=PALETTE[i%PALETTE.length]; polys.push({ poly, center:c.slice(), originalCenter:c.slice(), originalPoly:poly.map(p=>p.slice()), hue, baseHue:hue, targetHue:hue, velocity:{x:0,y:0}, breathPhase:Math.random()*Math.PI*2, colorPhase:Math.random()*Math.PI*2, colorSpeed:rand(0.005,0.015), lastRenderedHue:null }); } state={polys, colors:polys.map(({hue})=>HSL(hue,70,75))}; }
    function updateNaturalColors(){ for(const b of state.polys){ b.colorPhase+=b.colorSpeed; const off=Math.sin(b.colorPhase)*30; b.hue=(b.baseHue+off+360)%360; } }
    function updateBreathing(){ for(const b of state.polys){ b.breathPhase+=0.012; const s=1+Math.sin(b.breathPhase)*0.08; for(let i=0;i<b.poly.length;i++){ const dx=b.originalPoly[i][0]-b.originalCenter[0]; const dy=b.originalPoly[i][1]-b.originalCenter[1]; b.poly[i][0]=b.center[0]+dx*s; b.poly[i][1]=b.center[1]+dy*s; } } }
    function updateBlobPositions(){ const w=canvas.width,h=canvas.height; explosions=explosions.filter(e=>{e.strength*=0.95; e.age+=1; return e.age<120;}); for(const b of state.polys){ const dx=mousePos.x-b.center[0], dy=mousePos.y-b.center[1]; const d=Math.hypot(dx,dy); const AR=120*DPR, TR=300*DPR; for(const e of explosions){ const ex=b.center[0]-e.x, ey=b.center[1]-e.y; const ed=Math.hypot(ex,ey); if(ed<e.radius&&ed>0){ const f=e.strength*(e.radius-ed)/e.radius; b.velocity.x+=(ex/ed)*f; b.velocity.y+=(ey/ed)*f; } } if(d<AR&&d>0){ const f=(AR-d)/AR*6.0; b.velocity.x-=(dx/d)*f; b.velocity.y-=(dy/d)*f; } else if(d<TR){ const f=(TR-d)/TR*1.5; b.velocity.x+=(dx/d)*f; b.velocity.y+=(dy/d)*f; } const k=0.03; b.velocity.x+=(b.originalCenter[0]-b.center[0])*k; b.velocity.y+=(b.originalCenter[1]-b.center[1])*k; b.center[0]=Math.max(PADDING, Math.min(w-PADDING, b.center[0]+(b.velocity.x*=0.80))); b.center[1]=Math.max(PADDING, Math.min(h-PADDING, b.center[1]+(b.velocity.y*=0.80))); } }
    function updateColorSpreading(){ for(let i=0;i<state.polys.length;i++){ const a=state.polys[i]; let s=0,w=0; for(let j=0;j<state.polys.length;j++){ if(i===j) continue; const b=state.polys[j]; const d=Math.hypot(b.center[0]-a.center[0], b.center[1]-a.center[1]); if(d<80*DPR){ const ww=(80*DPR-d)/(80*DPR)*0.02; s+=b.hue*ww; w+=ww; } } if(w>0){ const avg=s/w; a.targetHue=a.hue+(avg-a.hue)*0.05; a.hue+=(a.targetHue-a.hue)*0.01; } } for(let i=0;i<state.polys.length;i++){ const b=state.polys[i]; if(Math.abs(b.hue-b.lastRenderedHue)>1||!b.lastRenderedHue){ state.colors[i]=HSL(b.hue,70,75); b.lastRenderedHue=b.hue; } } }
    function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); for(let i=0;i<state.polys.length;i++){ ctx.fillStyle=state.colors[i]; drawRoundedPath(ctx, state.polys[i].poly); ctx.fill(); } }
    function animate(){ updateNaturalColors(); updateBlobPositions(); updateBreathing(); updateColorSpreading(); draw(); requestAnimationFrame(animate); }
    function onMove(e){ const r=canvas.getBoundingClientRect(); mousePos.x=(e.clientX-r.left)*(canvas.width/r.width); mousePos.y=(e.clientY-r.top)*(canvas.height/r.height); }
    function onClick(e){ const r=canvas.getBoundingClientRect(); const x=(e.clientX-r.left)*(canvas.width/r.width); const y=(e.clientY-r.top)*(canvas.height/r.height); explosions.push({x,y,radius:300*DPR,strength:25,age:0}); }
    function resize(){ const w=Math.floor(window.innerWidth), h=Math.floor(window.innerHeight); canvas.width=w*DPR; canvas.height=h*DPR; canvas.style.width=w+'px'; canvas.style.height=h+'px'; regenerate(); draw(); }
    window.addEventListener('resize', resize); canvas.addEventListener('mousemove', onMove); canvas.addEventListener('click', onClick); resize(); requestAnimationFrame(animate);
  })();
  </script>
</body>
</html>


